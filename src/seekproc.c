/*
* $Author: leoboiko $
* $Locker:  $
*
* $Revision: 1.7 $
* $Date: 2005/11/24 21:03:07 $
* $Source: /cvsroot/chessd/chessd2/src/seekproc.c,v $
***
* $Log: seekproc.c,v $
* Revision 1.7  2005/11/24 21:03:07  leoboiko
* programmatically deleted all trailing whitespace (damn vim users)
*
* Revision 1.6  2005/11/23 02:50:13  leoboiko
* Many improvements.  Sorry for the batch commit, work had been done in
* the 0.1 "branch".
*
* Be warned that these changes are not enough yet for a working chessd.
*
* Code:
*  - fixed symbol redefinitions
*  - fixed implicit declarations
*  - removed static declarations on header files
*  - fixed some other gcc warnings
*  - rename badly-named src/config.h
*  - fixed wrong path to libltdl
*
* Build system:
*  - removed many autogenerated files from cvs
*  - check for libxml2
*  - better usage of libltdl, gettext
*  - check for libpq includes
*  - chessd.conf now on sysconfdir
*
* Misc:
*  - Added INSTALL-CVS
*  - removed dbinstall.sh, added create.sql
*
* Revision 1.5  2005/05/04 11:24:52  gabrielsan
* The protocol have been extended. If the user sets the ext_protocol interface
* variable, some extra messages are sent to help the client acquire information
* about the user and about challenges.
*
* Revision 1.4  2004/05/05 22:42:12  gabrielsan
* removed pstat
*
* Revision 1.3  2004/03/26 23:25:03  gabrielsan
* Fixed the identical IDs bug. Now the adjourned games are correctly
* restarted.
*
* Revision 1.2  2004/01/29 19:24:59  gabrielsan
* More fixes to the adjourned games subject.
*
* Revision 1.1  2004/01/12 19:36:14  svmello
* merging older version
*
* Revision 1.10  2003/12/17 16:31:12  debona
* Removed TDB library sources.
* Adaptations de dynamic linked TDB library
* Config now checks for TDB library on target machine
* Makefiles modifications for ltdl e some casts to avoid warnings
* Contribuitions for BSD compilation. (  Thanks! Vladimir Koukaev )
*
* Revision 1.9  2003/10/22 19:40:15  svmello
* Changes in string for "No avaliable space of the ad"
*
* Revision 1.8  2003/10/22 19:38:09  svmello
* MAXSEEK changed from 200 to 2000
*
* Revision 1.7  2003/10/17 20:43:52  svmello
* Corrected unseek and sought.
*
* Revision 1.6  2003/10/17 14:26:36  svmello
* Added support for seek / unseek / play / shought from ICS.
* The code is actually compilling, but isn't tested enought.
* I will clean this code later.
*
* Revision 1.6  1997/02/27 16:05:54  chess
* New constant
*
* Revision 1.5  1997/02/12 13:03:51  chess
* *** empty log message ***
*
* Revision 1.4  1997/01/26 21:22:44  chess
* prov show support
*
* Revision 1.3  1996/11/06 01:37:43  chess
* *** empty log message ***
*
* Revision 1.2  1996/11/06 01:14:53  chess
* added rcsid variable for tracking compiled code.
* with ident.
*
* Revision 1.1  1996/11/06 00:18:46  chess
* Initial revision
*
*/

/*
 *  seek.c
 *
 *  a part of FICS
 *
 *  Written by Hawk, 1st of August 1996.
 *
 */
/*
 * Change: Shane, October 14 1996: seek/sought now shows a (C) after
 *  the names of computers in seeks and the sought list.
 */

#include "playerdb.h"
#include "gamedb.h"
#include "gameproc.h"
#include "matchproc.h"
#include "utils.h"
#include "obsproc.h"
#include "seekproc.h"
#include "formula.h"
#include "ratings.h"
#include "globals.h"
#include "pending.h"
#include "configuration.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* Xaa: compatibility issues */
#define Bell(a)		pprintf_noformat(a,"\007")
/* Xaa: end of them */

#define REUSETIME 90    /* wait 90 secs before reusing old index */

typedef struct {
  int player;
  int ownrating;  /* makes life simpler */
  int time;
  int inc;
  int rated;
  int color;
  int type;       /* will be set by game_isblitz() */
  int min_rating;
  int max_rating;
  int formula;
  int lastused;      /* used to make a delay before reuse */
  char category[15];   /* makes life simpler */
  char board[30];      /* makes life simpler */
} SeekTuple;

#define MAXSEEK 2000
#define NOVALUE -1
#define COL_RANDOM -1
#define COL_BLACK 0
#define COL_WHITE 1
#define OppColor(C)  (((C) == COL_RANDOM)  ?  COL_RANDOM  :  !(C))

SeekTuple seekList[MAXSEEK];

static int BoardExists(char *p1,char *p2)
{
  char fname[MAX_FILENAME_SIZE];

  sprintf(fname,"%s/%s/%s",BOARD_DIR,p1,p2);
  return(file_exists(fname));
}

static void seekclear(SeekTuple *s)
{
  s->player = s->ownrating = s->time = s->inc = s->rated = s->color = NOVALUE;
  s->type = TYPE_UNTIMED;
  s->min_rating = s->max_rating = s->lastused = NOVALUE;
  s->formula = NOVALUE;
  s->category[0] = s->board[0] = '\0';
}

static int seekcount(int p)
{
  int i, count = 0;

  for (i = 0; (i < MAXSEEK); i++)
    if (seekList[i].player == p)
      count++;
  return count;
}

static int seekfind(int p)
{
  int i;

  for (i = 0; (i < MAXSEEK); i++)
    if (seekList[i].player == p)
      return i;
  return -1;
}

static int seekisduplet(SeekTuple* s2)
{
  int i;
  SeekTuple *s1;

  for (i = 0; (i < MAXSEEK); i++) {
    s1 = &seekList[i];
    if (s1->player   == s2->player &&
	s1->time     == s2->time   &&
	s1->inc      == s2->inc    &&
	s1->rated    == s2->rated  &&
	s1->color    == s2->color  &&
	s1->type     == s2->type   &&
	!strcmp(s1->category, s2->category) &&
	!strcmp(s1->board,    s2->board))
      return i;
  }
  return -1;
}

static int seekmatch(SeekTuple *s2)
{
  int i;
  SeekTuple *s1;
  textlist *clauses = NULL;

  for (i = 0; (i < MAXSEEK); i++) {
    s1 = &seekList[i];
    if ((s1->player   != s2->player   &&
	 s1->time     == s2->time     &&
	 s1->inc      == s2->inc      &&
	 s1->rated    == s2->rated    &&
	 s1->type     == s2->type)     &&
	((s1->color == COL_RANDOM && s2->color == COL_RANDOM) ||
	 (s1->color == COL_WHITE && s2->color == COL_BLACK) ||
	 (s1->color == COL_BLACK && s2->color == COL_WHITE)) &&
	(s1->ownrating >= s2->min_rating &&
	 s1->ownrating <= s2->max_rating &&
	 s2->ownrating >= s1->min_rating &&
	 s2->ownrating <= s1->max_rating) &&
	!strcmp(s1->category, s2->category) &&
	!strcmp(s1->board,    s2->board) &&
        (s1->formula != 1 ||
           GameMatchesFormula(s2->player, s1->player, s2->time, s2->inc,
                s1->time, s1->inc, s1->rated, s1->type, /*s2->color,*/ &clauses)) &&
        (s2->formula != 1 ||
           GameMatchesFormula(s1->player, s2->player, s1->time, s1->inc,
                s2->time, s2->inc, s1->rated, s1->type, /*s1->color,*/ &clauses)))
      return i;
  }
  return -1;
}

static int seekadd(SeekTuple s)
{
  int i;

  for (i = 0; (i < MAXSEEK); i++) {
    if (seekList[i].player == NOVALUE &&
	seekList[i].lastused + REUSETIME < time(0)) {
      seekList[i] = s;
      break;
    }
  }
  return ((i == MAXSEEK) ? -1 : i);
}

void seekremoveall(int p)
{
  int i;

  for (i = 0; (i < MAXSEEK); i++)
    if (seekList[i].player == p) {
      seekclear(&seekList[i]);
      seekList[i].lastused = time(0);
    }
}

static int seekremovead(int p, int i)
{
  if (seekList[i].player == p) {
    seekclear(&seekList[i]);
    seekList[i].lastused = time(0);
    return 1;
  } else {
    return 0;
  }
}

int is_number(char *s)
{
  int i;

  for (i = 0; s[i]; i++)
    if (!isdigit(s[i]))
      return 0;
  return 1;
}

int isrange(char *s, int *min, int *max)
{
  char *n1, *n2, *n3;

  n1 = strtok(s, "-");
  n2 = strtok(NULL, "-");
  n3 = strtok(NULL, "-");
  if (n1 && is_number(n1) && n2 && is_number(n2) && !n3) {
    *min = atoi(n1);
    *max = atoi(n2);
    return 1;
  }
  return 0;
}

void seekinit()
{
  int i;

  for (i = 0; (i < MAXSEEK); i++)
    seekclear(&seekList[i]);
}

void unseekall(int p)
{
  seekremoveall(p);
}

int com_seek(int p, param_list param)
{
  SeekTuple s;
  textlist *clauses = NULL;
  int i, seekindex, p1, min, max, count = 0;
  /* int pglicko = 1; */
  char typestring[20];

  /*
   *  Check if player is supposed to be able to seek matches
   */
  /* Xaa... we don't have this check...
  if (TooManyStored(p)) {
    pprintf (p, "You may not start a new match if you have more than %d"
	     " adjourned games.\n", MaxAdjourned(p));
    return COM_OK;
  }
  */
  if (seekcount(p) == MAX_PLAYER_SEEK) {
    pprintf(p, "You may only have %d ads active.\n",MAX_PLAYER_SEEK);
    return COM_OK;
  }
  if (player_globals.parray[p].game >= 0) {
    pprintf(p, "You are %s a game.\n",
	    (game_globals.garray[player_globals.parray[p].game].status == GAME_EXAMINE ||
	     game_globals.garray[player_globals.parray[p].game].status == GAME_SETUP) ?
	    "examining" : "playing");
    return COM_OK;
  }
  /* Xaa: we don't have a tourney flag
  if (CheckPFlag(p, PFLAG_TOURNEY)) {
    pprintf(p, "It appears you are in a tournament.  Finish it first.\n");
    return COM_OK;
  }
  */

  /*
   *  Parse the cmdline and fillout the tuple
   */
  seekclear(&s);
  for (i = 0; (param[i].type == TYPE_WORD); i++) {
    if (is_number(param[i].val.word)) {
      if (s.time == NOVALUE) {
	if ((s.time = atoi(param[i].val.word)) < 0) {
	  pprintf(p, "You can't specify negative values.\n");
	  return COM_OK;
	}
      } else if (s.inc == NOVALUE) {
	if ((s.inc = atoi(param[i].val.word)) < 0) {
	  pprintf(p, "You can't specify negative values.\n");
	  return COM_OK;
	}
      } else {
	pprintf(p, "Trying to specify several time controls?\n");
	return COM_OK;
      }
    } else if (isrange(param[i].val.word, &min, &max)) {
      if (s.min_rating == NOVALUE) {
	if (min < 0 || max < 0 || max <= min) {
	  pprintf(p, "Invalid range specified.\n");

	  return COM_OK;
	} else {
	  s.min_rating = min;
	  s.max_rating = max;
	}
      } else {
	pprintf(p, "Trying to specify several ranges?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "rated") || !strcmp(param[i].val.word, "r")) {
      if (s.rated == NOVALUE) {
	s.rated = 1;
      } else if (s.rated == 0) {
	pprintf(p, "Trying to confuse me? :)\n");
	return COM_OK;
      } else {
	pprintf(p, "Why specify 'rated' several times?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "unrated") || !strcmp(param[i].val.word, "u")) {
      if (s.rated == NOVALUE) {
	s.rated = 0;
      } else if (s.rated == 1) {
	pprintf(p, "Trying to confuse me? :)\n");
	return COM_OK;
      } else {
	pprintf(p, "Why specify 'unrated' several times?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "white") || !strcmp(param[i].val.word, "w")) {
      if (s.color == NOVALUE) {
	s.color = COL_WHITE;
      } else if (s.color == COL_BLACK) {
	pprintf(p, "Trying to confuse me? :)\n");
	return COM_OK;
      } else {
	pprintf(p, "Why specify 'white' several times?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "black") || !strcmp(param[i].val.word, "b")) {
      if (s.color == NOVALUE) {
	s.color = COL_BLACK;
      } else if (s.color == COL_WHITE) {
	pprintf(p, "Trying to confuse me? :)\n");
	return COM_OK;
      } else {
	pprintf(p, "Why specify 'black' several times?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "formula") || !strcmp(param[i].val.word, "f")) {
      if (s.formula == NOVALUE) {
	s.formula = 1;
      } else if (s.formula == 0) {
	pprintf(p, "Trying to confuse me? :)\n");
	return COM_OK;
      } else {
	pprintf(p, "Why specify 'formula' several times?\n");
	return COM_OK;
      }
    } else if (!strncmp(param[i].val.word, "w", 1) &&
	       strlen(param[i].val.word) > 1 &&
	       is_number(&(param[i].val.word[1]))) {
      if (s.category[0] == '\0') {
	strcpy(s.category, "wild");
	sprintf(s.board, "%d", atoi(&(param[i].val.word[1])));
      } else {
	pprintf(p, "Why specify several game types?\n");
	return COM_OK;
      }
    } else if (!strncmp(param[i].val.word, "wild", 4) &&
	       strlen(param[i].val.word) > 4 &&
	       is_number(&(param[i].val.word[4]))) {
      if (s.category[0] == '\0') {
	strcpy(s.category, "wild");
	sprintf(s.board, "%d", atoi(&(param[i].val.word[4])));
      } else {
	pprintf(p, "Why specify several game types?\n");
	return COM_OK;
      }
    } else if (!strcmp(param[i].val.word, "wild")
               && param[i+1].type == TYPE_WORD
               && BoardExists(param[i].val.word, param[i+1].val.word)) {
      if (s.category[0] == '\0') {
        strcpy (s.category, param[i].val.word);
        i++;
        strcpy (s.board, param[i].val.word);
      } else {
        pprintf(p, "Why specify several game types?\n");
        return COM_OK;
      }
    } else {
      pprintf(p, "Couldn't parse %s in seek command.\n", param[i].val.word);
      return COM_OK;
    }
  }

  /*
   *  Validate the values;  check for missing values and assign a default
   *  value to it if possible.
   */

  if (s.time == NOVALUE)
    s.time = player_globals.parray[p].d_time;
  if (s.inc == NOVALUE)
    s.inc = player_globals.parray[p].d_inc;
  if (s.time > 999 || s.inc > 999) {
    pprintf(p, "You can't specify such a large time control.\n");
    return COM_OK;
  }

  if (s.rated == NOVALUE)
     s.rated = BoolCheckPFlag(p, PFLAG_RATED);

  if (s.rated && !CheckPFlag(p, PFLAG_REG)) {
    pprintf(p, "As an unreg you cannot play rated games.\n");
    return COM_OK;
  }

  if (s.formula == NOVALUE)
    s.formula = 0;
  if (s.min_rating == NOVALUE)
    s.min_rating = 0;
  if (s.max_rating == NOVALUE)
    s.max_rating = 9999;
  if (s.color == NOVALUE)
    s.color = COL_RANDOM;
  s.player = p;
  s.type = game_isblitz(s.time, s.inc, s.time, s.inc, s.category, s.board);

  /* Check if the player can seek rated games */

  /* Xaa: we don't do banned rated
  if ((s.rated) && (banned_rated(p,-1,s.type))) {
    return COM_OK;
  }
  */

  if ((s.category[0] != '\0') && (!s.time) && (!s.inc)) {
    pprintf (p, "You can't play wild/non-standard positions untimed.\n");
    return COM_OK;
  }

  s.ownrating = GetRating(&player_globals.parray[p], s.type/*, pglicko*/);
  if (!strcmp(s.category,"wild")) {
    char fname[80];
    sprintf(fname, "%s/%s/%s", BOARD_DIR, s.category, s.board);
    if (!file_exists(fname)) {
      pprintf(p, "No such category/board: %s/%s\n", s.category, s.board);
      return COM_OK;
    }
  }

  /*
   *  Check for duplet
   */
  if ((seekindex = seekisduplet(&s)) >= 0) {
    if (seekList[seekindex].formula != s.formula) {
      pprintf(p, "Updating active ad");
      if (seekList[seekindex].formula != s.formula) {
        pprintf(p, "; formula %s be checked",
                      (s.formula  ?  "WILL"  :  "will NOT"));
        seekList[seekindex].formula = s.formula;
      }
      pprintf (p, ".\n");
    } else {
      pprintf(p, "You already have an ad active with the same game parameters.\n");
    }
    return COM_OK;
  }

  /*
   *  Check if it should be interpreted as an accept to another ad
   */
  if ((seekindex = seekmatch(&s)) != -1 &&
      (!player_censored(p, p1 = seekList[seekindex].player) &&
       !player_censored(p1, p) &&
       !in_list(p1, L_NOPLAY, player_globals.parray[p].login) &&
       !in_list(p, L_NOPLAY, player_globals.parray[p1].login) &&
       !in_list(p1, L_COMPUTER, player_globals.parray[p1].name)
       )) {    /* Manual requests should not be autoaccept. */
    /*
     *  Was originally planning on checking both players'
     *  formula - but figured that was nonsense.   -- Hawk
     */
    /*  I added formula checking in seekmatch().   -- hersco */

    pprintf(p, "Your ad matches an ad already posted by %s.\n", player_globals.parray[p1].name);
    pcommand(p, "play %d\n", seekindex);

	return COM_OK;
  }

  /*
   *  Add the tuple it to the list of ads
   */
  if ((seekindex = seekadd(s)) == -1) {
    pprintf(p, "No available space for the ad. -- try again later\n");
    d_printf("seek(): augh!  seek array all used\n");
    return COM_OK;
  }

  /*
   *  Inform the other players of the new ad
   */
  for (p1 = 0; (p1 < player_globals.p_num); p1++) {
    if ((p == p1 || player_globals.parray[p1].status != PLAYER_PROMPT) ||
	!CheckPFlag(p1, PFLAG_ADS) ||
	player_globals.parray[p1].game >= 0 ||
	/* Xaa: we don't have tourney flag
	CheckPFlag(p1, PFLAG_TOURNEY) ||
	*/
	player_censored(p, p1) ||
	player_censored(p1, p) ||
	in_list(p1, L_NOPLAY, player_globals.parray[p].login) ||
	in_list(p, L_NOPLAY, player_globals.parray[p1].login) ||
	GetRating(&player_globals.parray[p1], s.type/*, pglicko*/) < s.min_rating ||
	GetRating(&player_globals.parray[p1], s.type/*, pglicko*/) > s.max_rating ||
	/*
	 *  Check if ad would be accepted by the players formula
	 */
	!GameMatchesFormula(p, p1, s.time, s.inc, s.time, s.inc, s.rated,
			    s.type, /*s.color,*/ &clauses) ||
	/*
	 *  We may have to check seeker's formula too.
	 */
        (s.formula == 1 &&
            !GameMatchesFormula(p1, p, s.time, s.inc, s.time, s.inc, s.rated,
			    s.type, /*OppColor(s.color),*/ &clauses)))
      continue;
    if (s.category[0] != '\0' && s.type != TYPE_UNTIMED /* &&
	s.type != TYPE_ATOMIC && s.type != TYPE_SUICIDE */ )
      sprintf(typestring, "%s/%s", s.category, s.board);
    else
      strcpy(typestring, bstr[s.type]);
    pprintf_prompt(p1, "\n%s%s (%s) seeking %d %d %s %s %s%s(\"play %d\" to respond)\n",
		   player_globals.parray[p].name,
                   (in_list(p,L_COMPUTER,player_globals.parray[p].name) ? "(C)" : ""),
		   eattailwhite(ratstrii(s.ownrating,p)),
		   /* Xaa says BRRR!!!!
		   eattailwhite(ratstrii_prov(s.ownrating, p, RateType(s.type),
                                          p1)),
		   */
		   s.time,
		   s.inc,
		   (s.rated) ? "rated" : "unrated",
		   typestring,
		   colorstr[s.color+1],
		   (s.formula) ? "f " : "",
		   seekindex);
    count++;
  }
  pprintf(p, "Your ad has been posted with index %d.\n"
	  "(%d players currently meet the ad.)\n", seekindex, count);
  return COM_OK;
}

int com_unseek(int p, param_list param)
{
  if (seekcount(p) == 0) {
    pprintf(p, "You have no ads pending.\n");
  } else {
    if (param[0].type == TYPE_INT) {
      if (seekremovead(p, param[0].val.integer)) {
	pprintf(p, "Your ad #%d has been removed.\n", param[0].val.integer);
      } else {
	pprintf(p, "You have no ad #%d\n", param[0].val.integer);
      }
    } else {
      seekremoveall(p);
      pprintf(p, "Your ads have been removed.\n");
    }
  }
  return COM_OK;
}

int com_sought(int p, param_list param)
{
  int i, p1, filter, count = 0;
  textlist *clauses = NULL;
  /* int p1glicko; */
  char typestring[50];
  char namestring[50];

  if (param[0].type == TYPE_WORD) {
    if (!strcmp(param[0].val.word, "all") ||
	!strcmp(param[0].val.word, "a")) {
      filter = 0;
    } else {
      pprintf(p, "What do you mean by \"%s\" ?\n", param[0].val.word);
      return COM_OK;
    }
  } else {
    filter = 1;
  }

  for (i = 0; (i < MAXSEEK); i++) {
    if ((p1 = seekList[i].player) == NOVALUE)
      continue;

    if (filter) {
      /*
      p1glicko = 1;
      */
      if (player_censored(p, p1) ||
	  player_censored(p1, p) ||
	  in_list(p1, L_NOPLAY, player_globals.parray[p].login) ||
	  in_list(p, L_NOPLAY, player_globals.parray[p1].login) ||
	  GetRating(&player_globals.parray[p], seekList[i].type/*, p1glicko*/)
                    < seekList[i].min_rating ||
	  GetRating(&player_globals.parray[p], seekList[i].type/*, p1glicko*/)
                    > seekList[i].max_rating ||
	  !GameMatchesFormula(p1, p, seekList[i].time, seekList[i].inc,
			      seekList[i].time, seekList[i].inc,
			      seekList[i].rated, seekList[i].type,
			      /*seekList[i].color,*/ &clauses) ||
          ((seekList[i].formula == 1) &&
	      !GameMatchesFormula(p, p1, seekList[i].time, seekList[i].inc,
				  seekList[i].time, seekList[i].inc,
				  seekList[i].rated, seekList[i].type,
				  /*OppColor(seekList[i].color),*/ &clauses)))
	continue;
    }
    if (seekList[i].category[0] != '\0' && seekList[i].type != TYPE_UNTIMED) {
      if (!strcmp(seekList[i].category,"atomic"))
	sprintf(typestring, "atomic");
      else
      if (!strcmp(seekList[i].category,"suicide"))
        sprintf(typestring, "suicide");
      else
        sprintf(typestring, "%s/%s", seekList[i].category, seekList[i].board);
      }
    else
      strcpy(typestring, bstr[seekList[i].type]);
    if (in_list(p1, L_COMPUTER, player_globals.parray[p1].name))
      sprintf(namestring, "%s(C)", player_globals.parray[p1].name);
    else
      strcpy(namestring, player_globals.parray[p1].name);
    pprintf(p, "%3d %s %-17s %3d %3d %-7s %-9s %-8s %4d-%4d %s\n",
	    i,
	    ratstrii(seekList[i].ownrating,p1),
	    /* Xaa says Brrr!
	    ratstrii_prov(seekList[i].ownrating, p1, RateType(seekList[i].type), p),
	    */
	    namestring,
	    seekList[i].time,
	    seekList[i].inc,
	    (seekList[i].rated) ? "rated" : "unrated",
	    typestring,
	    colorstr[seekList[i].color+1],
	    seekList[i].min_rating,
	    seekList[i].max_rating,
	    (seekList[i].formula) ? "f" : "");
    count++;
  }
  pprintf(p, "%d ad%s displayed.\n", count, (count == 1) ? "" : "s");
  return COM_OK;
}

int com_play(int p, param_list param)
{
	int p1, g, i /*, p1glicko*/ ;
	textlist *clauses = NULL;

	/*
	 *  Check if player is allowed to respond to ads
	 */
	/* OliB: Why not, everyone can !computer his formula */
	/* if (in_list(p, L_COMPUTER, player_globals.parray[p].name)) {
	   pprintf(p, "Sorry.  Computers aren't allowed to respond to ads.\n");
	   return COM_OK;
	   }*/
	/* Xaa: we don't do TooManyStored here
	   if (TooManyStored(p)) {
	   pprintf (p, "You may not start a new match if you have more than %d"
	   " adjourned games.\n", MaxAdjourned(p));
	   return COM_OK;
	   }
	 */

	/*
	 *  Find the opponent and the seekindex
	 */
	if (param[0].type == TYPE_WORD) {
		stolower(param[0].val.word);
		if ((p1 = player_find_part_login(param[0].val.word)) < 0) {
			pprintf(p, "No user named %s is logged in.\n", param[0].val.word);
			return COM_OK;
		}
		if (seekcount(p1) == 0) {
			pprintf(p, "%s isn't seeking any games.\n", player_globals.parray[p1].name);
			return COM_OK;
		} else if (seekcount(p1) > 1) {
			pprintf(p, "%s is seeking several games.  Please be more specific.\n",
					player_globals.parray[p1].name);
			return COM_OK;
		} else {
			i = seekfind(p1);
		}
	} else {
		i = param[0].val.integer;
		if (!(i >= 0 && i < MAXSEEK &&
					seekList[i].player != NOVALUE)) {
			pprintf(p, "Bad index given; no such ad.\n");
			return COM_OK;
		}
	}
	if (i == -1) {
		pprintf(p, "Should have found ad - but didn't.  Inform an admin.\n");
		d_printf("com_play(): Augh! Should have found ad - but didn't.\n");
	}

	/*
	 *  Make sure players don't answer their own ads
	 */
	if (p == (p1 = seekList[i].player)) {
		pprintf(p, "You can't respond to your own ads.\n");
		return COM_OK;
	}

	/*
	 *  Check if player should be able to play someone now
	 */
	if (player_globals.parray[p].game >= 0) {
		pprintf(p, "You are %s a game.\n",
				(game_globals.garray[player_globals.parray[p].game].status == GAME_EXAMINE ||
				 game_globals.garray[player_globals.parray[p].game].status == GAME_SETUP) ?
				"examining" : "playing");
		return COM_OK;
	}
	/* Xaa: we don't have a tournament flag
	   if (CheckPFlag(p, PFLAG_TOURNEY)) {
	   pprintf(p, "It appears you are in a tournament.  Finish it first.\n");
	   return COM_OK;
	   }
	   if (CheckPFlag(p1, PFLAG_TOURNEY)) {
	   pprintf(p, "It appears your opponent is playing in a tournament.\n");
	   return COM_OK;
	   }
	 */
	/*
	 *  Check if the opponent is playing - if so, IT'S A BUG!
	 *  The ad should have been removed when the player started
	 *  a game.
	 */
	if (player_globals.parray[p1].game >= 0 &&
		game_globals.garray[player_globals.parray[p1].game].status == GAME_ACTIVE) {

		pprintf(p, "Bug detected! -- Your opponent is already playing a game.\n");
		d_printf("com_play(): BUG: ad should have been removed!\n");

		return COM_OK;
	}

	/*
	 *  Make sure opponent isn't examining a game
	 */
	if ((player_globals.parray[p1].game >= 0) &&
			(game_globals.garray[player_globals.parray[p1].game].status == GAME_EXAMINE ||
			 game_globals.garray[player_globals.parray[p1].game].status == GAME_SETUP)) {
		pcommand(p1, "unexamine");
	}

	/*
	 *  Check for adjourned game between the two players.
	 */

	g = game_new();
	if ((game_read(g, p, p1) >= 0) || (game_read(g, p1, p) >= 0)) {
		pprintf(p, "There exists an adjourned game between you and %s\n"
				"You must finish that game first!\n", player_globals.parray[p1].name);
		game_remove(g);
		return COM_OK;
	}
	game_remove(g);

	/*
	 *  Check if either one has the other on censor or noplay lists
	 */
	if (in_list(p1, L_NOPLAY, player_globals.parray[p].login)) {
		pprintf(p, "You are on %s's noplay list.\n", player_globals.parray[p1].name);
		return COM_OK;
	}
	if (in_list(p, L_NOPLAY, player_globals.parray[p1].login)) {
		pprintf(p, "You have %s on your noplay list.\n", player_globals.parray[p1].name);
		return COM_OK;
	}
	if (player_censored(p1, p)) {
		pprintf(p, "%s is censoring you.\n", player_globals.parray[p1].name);
		return COM_OK;
	}
	if (player_censored(p, p1)) {
		pprintf(p, "You are censoring %s.\n", player_globals.parray[p1].name);
		return COM_OK;
	}

	/*
	 *  Check if player matches the seek
	 */
	if (seekList[i].rated && !CheckPFlag(p, PFLAG_REG)) {
		pprintf(p, "As an unreg you cannot play rated games.\n");
		return COM_OK;
	}

	/* Check if the player can accept rated games */

	/* Xaa: we don't do banned_rated
	   if ((seekList[i].rated) && (banned_rated(p,-1,seekList[i].type))) {
	   return COM_OK;
	   }
	 */

	if (GetRating(&player_globals.parray[p], seekList[i].type/*, p1glicko*/)
			< seekList[i].min_rating ||
			GetRating(&player_globals.parray[p], seekList[i].type/*, p1glicko*/)
			> seekList[i].max_rating) {
		pprintf(p, "Your rating does not qualify for this ad.\n");
		return COM_OK;
	}
	/* Check formula if requested by seek. */

	if (seekList[i].formula == 1 &&
			!GameMatchesFormula(p, p1, seekList[i].time, seekList[i].inc,
				seekList[i].time, seekList[i].inc,
				seekList[i].rated, seekList[i].type,
				/*OppColor(seekList[i].color),*/ &clauses)) {
		pprintf (p, "Your challenge does not meet %s's formula.\n",
				player_globals.parray[p1].name);
		return COM_OK;
	}

	/*
	 *  Start the match
	 */
	pprintf(p, "You accept the challenge of %s.\n", player_globals.parray[p1].name);
	pprintf_prompt(p1, "\n%s accepts your challenge.\n", player_globals.parray[p].name);
	unobserveAll(p);
	unobserveAll(p1);
	g = game_new();
	create_new_match(g, p1, p,
			seekList[i].time, seekList[i].inc,
			seekList[i].time, seekList[i].inc,
			seekList[i].rated,
			seekList[i].category,
			seekList[i].board,
			seekList[i].color,
			0);
	seekremoveall(p);
	seekremoveall(p1);
	return COM_OK;
}
